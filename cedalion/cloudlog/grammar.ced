'/bootstrap':defAtom(ctxElem::'/bootstrap':type).
'/bootstrap':signature(term(TTerm,CtxIn,CtxOut)::'/parsing':pattern('/parsing':token(cloudlog)),[TTerm::'/bootstrap':typedTerm,CtxIn::'/bootstrap':list(ctxElem),CtxOut::'/bootstrap':list(ctxElem)]).
'/util':behavior(term(TTerm,CtxIn,CtxOut)::'/parsing':pattern('/parsing':token(cloudlog)),!'should accept string literals', ('/parsing':lexParseString(term(TTerm,[],_),!'"foo"',cloudlog),'/util':assertEqual(TTerm,!foo::'/bootstrap':string,'/bootstrap':typedTerm))).
'/parsing':prod(term(Str::'/bootstrap':string,Ctx,Ctx),'/parsing':token(cloudlog),'/parsing':terminal(string(Str))).
'/util':behavior(term(TTerm,CtxIn,CtxOut)::'/parsing':pattern('/parsing':token(cloudlog)),!'should accept number literals', ('/parsing':lexParseString(term(TTerm,[],_),!'-2.3E-4',cloudlog),'/util':assertEqual(TTerm,-0.00023::'/bootstrap':number,'/bootstrap':typedTerm))).
'/parsing':prod(term(Num::'/bootstrap':number,Ctx,Ctx),'/parsing':token(cloudlog),'/parsing':terminal(number(Num))).
'/util':behavior(term(TTerm,CtxIn,CtxOut)::'/parsing':pattern('/parsing':token(cloudlog)),!'should accept number literals', ('/parsing':lexParseString(term(TTerm,[],_),!'-2.3E-4',cloudlog),'/util':assertEqual(TTerm,-0.00023::'/bootstrap':number,'/bootstrap':typedTerm))).
'/bootstrap':signature(qName(Name,Ctx)::'/parsing':pattern('/parsing':token(cloudlog)),[Name::'/bootstrap':string,Ctx::'/bootstrap':list(ctxElem)]).
'/bootstrap':signature(package(Name)::ctxElem,[Name::'/bootstrap':string]).
'/util':behavior(qName(Name,Ctx)::'/parsing':pattern('/parsing':token(cloudlog)),!'should accept simple names under the package namespace', ('/parsing':lexParseString(qName(Name,[package(!foo)]),!bar,cloudlog),'/util':assertEqual(Name,!'foo#bar','/bootstrap':string))).
'/parsing':prod(qName(QName,Ctx),'/parsing':token(cloudlog),'/parsing':follow('/parsing':terminal(identifier(Name)),'/parsing':pred(('/bootstrap':listMember(package(Package),ctxElem,Ctx),'/Functional':eval('/Functional':applyBinOp('/Functional':applyBinOp('/Functional':const(Package),'/Functional':concat,'/Functional':const(!'#')),'/Functional':concat,'/Functional':const(Name)),'/bootstrap':string,QName))))).
'/util':behavior(qName(Name,Ctx)::'/parsing':pattern('/parsing':token(cloudlog)),!'should accept qualified names and use the qualifier as prefix if no import exists', ('/parsing':lexParseString(qName(Name,[]),!'foo:bar',cloudlog),'/util':assertEqual(Name,!'foo#bar','/bootstrap':string))).
'/bootstrap':signature(import(Qual,Prefix)::ctxElem,[Qual::'/bootstrap':string,Prefix::'/bootstrap':string]).
'/util':behavior(qName(Name,Ctx)::'/parsing':pattern('/parsing':token(cloudlog)),!'should accept qualified names and use the import as the prefix, if exists', ('/parsing':lexParseString(qName(Name,[import(!foo,!'/FOO')]),!'foo:bar',cloudlog),'/util':assertEqual(Name,!'/FOO#bar','/bootstrap':string))).
'/parsing':defSymbol(! (:),cloudlog).
annotation:shrink('/parsing':prod(qName(QName,Ctx),'/parsing':token(cloudlog),'/parsing':follow('/parsing':follow('/parsing':terminal(identifier(Qual)),'/parsing':follow('/parsing':terminal('/parsing':symbol(! (:))),'/parsing':terminal(identifier(Name)))),'/parsing':pred(builtin:if('/bootstrap':listMember(import(Qual,Prefix),ctxElem,Ctx),'/Functional':eval('/Functional':applyBinOp('/Functional':applyBinOp('/Functional':const(Prefix),'/Functional':concat,'/Functional':const(!'#')),'/Functional':concat,'/Functional':const(Name)),'/bootstrap':string,QName),'/Functional':eval('/Functional':applyBinOp('/Functional':applyBinOp('/Functional':const(Qual),'/Functional':concat,'/Functional':const(!'#')),'/Functional':concat,'/Functional':const(Name)),'/bootstrap':string,QName)))))).
'/util':behavior(term(TTerm,CtxIn,CtxOut)::'/parsing':pattern('/parsing':token(cloudlog)),!'should accept atomic compound terms', ('/parsing':lexParseString(term(TTerm,[package(!foo)],Ctx),!bar,cloudlog),builtin:parseTerm(TTerm,Name,[]),'/util':assertEqual(Name,!'foo#bar','/bootstrap':string))).
'/parsing':prod(term(TTerm,Ctx,Ctx),'/parsing':token(cloudlog),'/parsing':follow(qName(Name,Ctx),'/parsing':pred(builtin:parseTerm(TTerm,Name,[])))).
'/util':behavior(term(TTerm,CtxIn,CtxOut)::'/parsing':pattern('/parsing':token(cloudlog)),!'should accept compound terms', ('/parsing':lexParseString(term(TTerm,[],Ctx),!'foo:bar(1, 2, 3)',cloudlog),builtin:parseTerm(TTerm,Name,[1::'/bootstrap':number,2::'/bootstrap':number,3::'/bootstrap':number]),'/util':assertEqual(Name,!'foo#bar','/bootstrap':string))).
'/parsing':defSymbol(! (,),cloudlog).
'/parsing':defSymbol(!'(',cloudlog).
'/parsing':defSymbol(!')',cloudlog).
'/parsing':prod(term(TTerm,CtxIn,CtxOut),'/parsing':token(cloudlog),'/parsing':follow('/parsing':follow('/parsing':follow('/parsing':follow(qName(Name,CtxIn),'/parsing':terminal('/parsing':symbol(!'('))),termListNe(TArgs,CtxIn,CtxOut)),'/parsing':terminal('/parsing':symbol(!')'))),'/parsing':pred(builtin:parseTerm(TTerm,Name,TArgs)))).
'/bootstrap':signature(termListNe(TArgs,CtxIn,CtxOut)::'/parsing':pattern('/parsing':token(cloudlog)),[TArgs::'/bootstrap':list('/bootstrap':typedTerm),CtxIn::'/bootstrap':list(ctxElem),CtxOut::'/bootstrap':list(ctxElem)]).
'/parsing':prod(termListNe([TTerm|TArgs],CtxIn,CtxOut),'/parsing':token(cloudlog),'/parsing':follow(term(TTerm,CtxIn,CtxMid),termListSuffix(TArgs,CtxMid,CtxOut))).
'/bootstrap':signature(termListSuffix(TArgs,CtxMid,CtxOut)::'/parsing':pattern('/parsing':token(cloudlog)),[TArgs::'/bootstrap':list('/bootstrap':typedTerm),CtxMid::'/bootstrap':list(ctxElem),CtxOut::'/bootstrap':list(ctxElem)]).
'/parsing':prod(termListSuffix([],Ctx,Ctx),'/parsing':token(cloudlog),'/parsing':empty).
'/parsing':prod(termListSuffix(List,CtxIn,CtxOut),'/parsing':token(cloudlog),'/parsing':follow('/parsing':terminal('/parsing':symbol(! (,))),termListNe(List,CtxIn,CtxOut))).
'/util':behavior(term(TTerm,CtxIn,CtxOut)::'/parsing':pattern('/parsing':token(cloudlog)),!'should accept variables and add their names to the context', ('/parsing':lexParseString(term(TTerm,[],Ctx),!'Foo',cloudlog),'/util':assertEqual(Ctx,[varName(TTerm,!'Foo')],'/bootstrap':list(ctxElem)))).
'/util':behavior(term(TTerm,CtxIn,CtxOut)::'/parsing':pattern('/parsing':token(cloudlog)),!'should bind variables on matching names', ('/parsing':lexParseString(term(TTerm,[varName(Y::'/bootstrap':number,!'Y'),varName(X::'/bootstrap':number,!'X')],Ctx),!'X',cloudlog),'/util':assertEqual(TTerm,X::'/bootstrap':number,'/bootstrap':typedTerm))).
'/bootstrap':signature(varName(TVar,Name)::ctxElem,[TVar::'/bootstrap':typedTerm,Name::'/bootstrap':string]).
annotation:shrink('/parsing':prod(term(TTerm,CtxIn,CtxOut),'/parsing':token(cloudlog),'/parsing':follow('/parsing':terminal(varName(Name)),'/parsing':pred(builtin:if('/bootstrap':listMember(varName(TTerm,Name),ctxElem,CtxIn),CtxOut::'/bootstrap':list(ctxElem)=CtxIn::'/bootstrap':list(ctxElem),CtxOut::'/bootstrap':list(ctxElem)=[varName(TTerm,Name)|CtxIn]::'/bootstrap':list(ctxElem)))))).
'/util':behavior(term(TTerm,CtxIn,CtxOut)::'/parsing':pattern('/parsing':token(cloudlog)),!'should stream the context trhoughout a compound term', ('/parsing':lexParseString(term(TTerm,[package(!foo)],Ctx),!'a(X, b(Y, X), Y)',cloudlog),'/util':assertStracturallyEqual(TTerm,foo:a(X,foo:b(Y,X),Y)::_,'/bootstrap':typedTerm))).
'/bootstrap':signature(axiom(Axiom,CtxIn,CtxOut)::'/parsing':pattern('/parsing':token(cloudlog)),[Axiom::axiom,CtxIn::'/bootstrap':list(ctxElem),CtxOut::'/bootstrap':list(ctxElem)]).
'/util':behavior(axiom(Axiom,CtxIn,CtxOut)::'/parsing':pattern('/parsing':token(cloudlog)),!'should accept a compound term as a fact', ('/parsing':lexParseString(axiom(Axiom,[package(!example)],_),!'someFact(1, 2)',cloudlog),'/util':assertEqual(Axiom,example:someFact(1,2),axiom))).
'/parsing':prod(axiom(Fact,CtxIn,CtxOut),'/parsing':token(cloudlog),term(Fact::axiom,CtxIn,CtxOut)).
'/util':behavior(axiom(Axiom,CtxIn,CtxOut)::'/parsing':pattern('/parsing':token(cloudlog)),!'should accept guardless rules', ('/parsing':lexParseString(axiom(Axiom,[package(!example)],_),!'someFact(1, X) -> someFact(X, 2)',cloudlog),'/util':assertStracturallyEqual(Axiom,rule(example:someFact(1,X),builtin:true,example:someFact(X,2)),axiom))).
'/parsing':defSymbol(! (->),cloudlog).
'/parsing':prod(axiom(rule(Fact,builtin:true,Axiom),CtxIn,CtxOut),'/parsing':token(cloudlog),'/parsing':follow('/parsing':follow(term(Fact::axiom,CtxIn,Ctx1),'/parsing':terminal('/parsing':symbol(! (->)))),axiom(Axiom,Ctx1,CtxOut))).
'/util':behavior(axiom(Axiom,CtxIn,CtxOut)::'/parsing':pattern('/parsing':token(cloudlog)),!'should accept guarded rules', ('/parsing':lexParseString(axiom(Axiom,[package(!example)],_),!'someFact(1, X) {builtin:succ(X, Y)} -> someFact(Y, 2)',cloudlog),'/util':assertStracturallyEqual(Axiom,rule(example:someFact(1,X),builtin:succ(X,Y),example:someFact(Y,2)),axiom))).
'/parsing':defSymbol(!'{',cloudlog).
'/parsing':defSymbol(!'}',cloudlog).
annotation:shrink('/parsing':prod(axiom(rule(Fact,Guard,Axiom),CtxIn,CtxOut),'/parsing':token(cloudlog),'/parsing':follow('/parsing':follow('/parsing':follow('/parsing':follow(term(Fact::axiom,CtxIn,Ctx1),'/parsing':follow('/parsing':terminal('/parsing':symbol(!'{')),term(Guard::'/bootstrap':pred,Ctx1,Ctx2))),'/parsing':terminal('/parsing':symbol(!'}'))),'/parsing':terminal('/parsing':symbol(! (->)))),term(Axiom::axiom,Ctx2,CtxOut)))).
