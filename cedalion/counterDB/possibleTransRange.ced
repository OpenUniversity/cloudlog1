'/bootstrap':signature(possibleTransCombination(Expr,CombIn,CombOut)::'/bootstrap':pred,[Expr::counterExpr,CombIn::'/bootstrap':list(threadCond),CombOut::'/bootstrap':list(threadCond)]).
'/util':behavior(counterValue(Num)::counterExpr,!'should not leave the list of possible transaction ranges untouched', (possibleTransCombination(counterValue(Num),[threadSeen(!'thr1',4)],Comb),builtin:equals(Comb::'/bootstrap':list(threadCond),[threadSeen(!'thr1',4)]::'/bootstrap':list(threadCond)))).
possibleTransCombination(counterValue(Num),Comb,Comb):-builtin:true.
'/util':behavior(counterIf(Expr,Thr,Trans,TS)::counterExpr,!'should provide the range Thr >= Trans', (possibleTransCombination(counterIf(Expr,!'thr2',7,TS),[threadSeen(!'thr1',4)],Comb),builtin:equals(Comb::'/bootstrap':list(threadCond),[threadSeen(!'thr2',7),threadSeen(!'thr1',4)]::'/bootstrap':list(threadCond)))).
annotation:shrink((possibleTransCombination(counterIf(Expr,Thr,Trans,TS),CombIn,[threadSeen(Thr,Trans)|CombOut]):-assertionMatches(threadSeen(Thr,Trans),CombIn),possibleTransCombination(Expr,CombIn,CombOut))).
'/util':behavior(counterIf(Expr,Thr,Trans,TS)::counterExpr,!'should provide the range not(Thr >= Trans)',possibleTransCombination(counterIf(Expr,!'thr2',7,TS),[threadSeen(!'thr1',4)],[threadNotSeen(!'thr2',7),threadSeen(!'thr1',4)])).
annotation:shrink((possibleTransCombination(counterIf(Expr,Thr,Trans,TS),CombIn,[threadNotSeen(Thr,Trans)|CombOut]):-assertionMatches(threadNotSeen(Thr,Trans),CombIn),possibleTransCombination(Expr,CombIn,CombOut))).
'/util':behavior(counterIf(Expr,Thr,Trans,TS)::counterExpr,!'should not provide Thr >= Trans if a conflicting assertion is already in CombIn',\+possibleTransCombination(counterIf(Expr,!thr,7,TS),[threadNotSeen(!thr,4)],[threadSeen(!thr,7),threadNotSeen(!thr,4)])).
'/util':behavior(counterIf(Expr,Thr,Trans,TS)::counterExpr,!'should provide Thr >= Trans for non-conflicting assertions in CombIn',possibleTransCombination(counterIf(Expr,!thr,7,TS),[threadNotSeen(!thr,9)],[threadSeen(!thr,7),threadNotSeen(!thr,9)])).
'/util':behavior(counterIf(Expr,Thr,Trans,TS)::counterExpr,!'should not provide not(Thr >= Trans) if a conflicting assertion is already in CombIn',\+possibleTransCombination(counterIf(Expr,!thr,7,TS),[threadSeen(!thr,14)],[threadNotSeen(!thr,7),threadSeen(!thr,14)])).
'/util':behavior(counterIf(Expr,Thr,Trans,TS)::counterExpr,!'should provide not(Thr >= Trans) for non-conflicting assertions in CombIn',possibleTransCombination(counterIf(Expr,!thr,7,TS),[threadSeen(!thr,4)],[threadNotSeen(!thr,7),threadSeen(!thr,4)])).
'/util':behavior(counterPlus(A,B)::counterExpr,!'should provide a combination of ranges from both A and B', (possibleTransCombination(counterPlus(counterIf(Expr,!'thr2',7,TS),counterIf(Expr,!'thr3',5,TS)),[threadSeen(!'thr1',4)],Comb),builtin:equals(Comb::'/bootstrap':list(threadCond),[threadSeen(!'thr3',5),threadSeen(!'thr2',7),threadSeen(!'thr1',4)]::'/bootstrap':list(threadCond)))).
annotation:shrink((possibleTransCombination(counterPlus(A,B),CombIn,CombOut):-possibleTransCombination(A,CombIn,CombA),possibleTransCombination(B,CombA,CombOut))).
