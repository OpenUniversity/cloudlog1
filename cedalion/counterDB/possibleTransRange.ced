'/bootstrap':signature(possibleTransCombination(Expr,CombIn,CombOut)::'/bootstrap':pred,[Expr::counterExpr,CombIn::'/bootstrap':list('/impred':impred),CombOut::'/bootstrap':list('/impred':impred)]).
'/util':behavior(counterValue(Num)::counterExpr,!'should not leave the list of possible transaction ranges untouched', (possibleTransCombination(counterValue(Num),[seen(!'thr1',4)],Comb),builtin:equals(Comb::'/bootstrap':list('/impred':impred),[seen(!'thr1',4)]::'/bootstrap':list('/impred':impred)))).
possibleTransCombination(counterValue(Num),Comb,Comb):-builtin:true.
'/util':behavior(counterIf(Expr,Thr,Trans,TS)::counterExpr,!'should provide the range Thr >= Trans', (possibleTransCombination(counterIf(Expr,!'thr2',7,TS),[seen(!'thr1',4)],Comb),builtin:equals(Comb::'/bootstrap':list('/impred':impred),[seen(!'thr2',7),seen(!'thr1',4)]::'/bootstrap':list('/impred':impred)))).
annotation:shrink((possibleTransCombination(counterIf(Expr,Thr,Trans,TS),CombIn,[seen(Thr,Trans)|CombOut]):-assertionMatches(seen(Thr,Trans),CombIn),possibleTransCombination(Expr,CombIn,CombOut))).
'/util':behavior(counterIf(Expr,Thr,Trans,TS)::counterExpr,!'should provide the range not(Thr >= Trans)',possibleTransCombination(counterIf(Expr,!'thr2',7,TS),[seen(!'thr1',4)],['/impred':not(seen(!'thr2',7)),seen(!'thr1',4)])).
annotation:shrink((possibleTransCombination(counterIf(Expr,Thr,Trans,TS),CombIn,['/impred':not(seen(Thr,Trans))|CombOut]):-assertionMatches('/impred':not(seen(Thr,Trans)),CombIn),possibleTransCombination(Expr,CombIn,CombOut))).
'/util':behavior(counterIf(Expr,Thr,Trans,TS)::counterExpr,!'should not provide Thr >= Trans if a conflicting assertion is already in CombIn',\+possibleTransCombination(counterIf(Expr,!thr,7,TS),['/impred':not(seen(!thr,4))],[seen(!thr,7),'/impred':not(seen(!thr,4))])).
'/util':behavior(counterIf(Expr,Thr,Trans,TS)::counterExpr,!'should provide Thr >= Trans for non-conflicting assertions in CombIn',possibleTransCombination(counterIf(Expr,!thr,7,TS),['/impred':not(seen(!thr,9))],[seen(!thr,7),'/impred':not(seen(!thr,9))])).
'/util':behavior(counterIf(Expr,Thr,Trans,TS)::counterExpr,!'should not provide not(Thr >= Trans) if a conflicting assertion is already in CombIn',\+possibleTransCombination(counterIf(Expr,!thr,7,TS),[seen(!thr,14)],['/impred':not(seen(!thr,7)),seen(!thr,14)])).
'/util':behavior(counterIf(Expr,Thr,Trans,TS)::counterExpr,!'should provide not(Thr >= Trans) for non-conflicting assertions in CombIn',possibleTransCombination(counterIf(Expr,!thr,7,TS),[seen(!thr,4)],['/impred':not(seen(!thr,7)),seen(!thr,4)])).
'/util':behavior(counterPlus(A,B)::counterExpr,!'should provide a combination of ranges from both A and B', (possibleTransCombination(counterPlus(counterIf(Expr,!'thr2',7,TS),counterIf(Expr,!'thr3',5,TS)),[seen(!'thr1',4)],Comb),builtin:equals(Comb::'/bootstrap':list('/impred':impred),[seen(!'thr3',5),seen(!'thr2',7),seen(!'thr1',4)]::'/bootstrap':list('/impred':impred)))).
annotation:shrink((possibleTransCombination(counterPlus(A,B),CombIn,CombOut):-possibleTransCombination(A,CombIn,CombA),possibleTransCombination(B,CombA,CombOut))).
