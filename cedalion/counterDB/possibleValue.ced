'/bootstrap':defAtom(threadCond::'/bootstrap':type).
'/bootstrap':signature(possibleValue(Expr,Assertions,Value)::'/bootstrap':pred,[Expr::counterExpr,Assertions::'/bootstrap':list(threadCond),Value::'/bootstrap':number]).
'/bootstrap':projection(possibleValue(Expr,Assertions,Value)::'/bootstrap':pred,'/bootstrap':horiz(['/bootstrap':vis(Value::'/bootstrap':number),'/bootstrap':label(!'is a possible value for'),'/bootstrap':vis(Expr::counterExpr),'/bootstrap':label(!under),'/bootstrap':vis(Assertions::'/bootstrap':list(threadCond))])).
'/bootstrap':signature(threadSeen(Thr,Trans)::threadCond,[Thr::'/bootstrap':string,Trans::'/bootstrap':number]).
'/bootstrap':projection(threadSeen(Thr,Trans)::threadCond,'/bootstrap':horiz(['/bootstrap':vis(Thr::'/bootstrap':string),'/bootstrap':symbol(8805),'/bootstrap':vis(Trans::'/bootstrap':number)])).
'/bootstrap':alias(threadSeen(Thr,Trans)::threadCond,! (>=)).
'/util':behavior(counterValue(Num)::counterExpr,!'should have only one possible value: Num, regardless of assertions',builtin:findall(Value,'/bootstrap':number,possibleValue(counterValue(4),[threadSeen(!'thr1',3)],Value),[4])).
possibleValue(counterValue(Num),_,Num):-builtin:true.
'/util':behavior(counterIf(Expr,Thr,Trans,TS)::counterExpr,!'should have two values: 0 and the value of Expr, if the Assertions allow this',builtin:findall(Value,'/bootstrap':number,possibleValue(counterIf(counterValue(4),!'thr1',3,100),[threadSeen(!'thr1',2)],Value),[0,4])).
possibleValue(counterIf(_,Thr,Trans,_),Assertions,0):-assertionMatches(threadNotSeen(Thr,Trans),Assertions).
annotation:shrink((possibleValue(counterIf(Expr,Thr,Trans,_),Assertions,V):-assertionMatches(threadSeen(Thr,Trans),Assertions),possibleValue(Expr,Assertions,V))).
'/bootstrap':signature(threadNotSeen(Thr,Trans)::threadCond,[Thr::'/bootstrap':string,Trans::'/bootstrap':number]).
'/bootstrap':projection(threadNotSeen(Thr,Trans)::threadCond,'/bootstrap':horiz(['/bootstrap':vis(Thr::'/bootstrap':string),'/bootstrap':label(! (<)),'/bootstrap':vis(Trans::'/bootstrap':number)])).
'/util':behavior(counterIf(Expr,Thr,Trans,TS)::counterExpr,!'should not provide the value of Expr if Thr >= Trans conflicts with Assertions',builtin:findall(Value,'/bootstrap':number,possibleValue(counterIf(counterValue(4),!'thr1',3,100),[threadNotSeen(!'thr1',1)],Value),[0])).
'/util':behavior(counterIf(Expr,Thr,Trans,TS)::counterExpr,!'should not provide 0 as value if not(Thr >= Trans) conflicts with Assertions',builtin:findall(Value,'/bootstrap':number,possibleValue(counterIf(counterValue(4),!'thr1',3,100),[threadSeen(!'thr1',5)],Value),[4])).
'/util':behavior(counterPlus(A,B)::counterExpr,!'should provide any value that can be the sum of any combination of the values of A and B',builtin:findall(Value,'/bootstrap':number, (possibleTransCombination(counterPlus(annotation:parentheses(counterIf(counterValue(4),!'thr1',3,100)),annotation:parentheses(counterIf(counterValue(5),!'thr1',6,100))),[],Assertions),possibleValue(counterPlus(annotation:parentheses(counterIf(counterValue(4),!'thr1',3,100)),annotation:parentheses(counterIf(counterValue(5),!'thr1',6,100))),Assertions,Value)),[9,4,0])).
possibleValue(counterPlus(A,B),Assertions,V):-possibleValue(A,Assertions,APrime),possibleValue(B,Assertions,BPrime),'/Functional':eval('/Functional':applyBinOp('/Functional':const(APrime),'/Functional':numPlus,'/Functional':const(BPrime)),'/bootstrap':number,V).
'/util':behavior(counterIf(Expr,Thr,Num,TS)::counterExpr,!'should provide ',builtin:findall(Value,'/bootstrap':number,possibleValue(counterIf(counterValue(4),!'thr1',3,100),[threadSeen(!'thr1',1)],Value),[0,4])).
'/bootstrap':tip(seen(Thr,Trans)::threadCond,Path,VNs,cpi:edit(Path,threadSeen(Thr,Trans)::threadCond,VNs)).
'/bootstrap':tip('/impred':not(seen(Thr,Trans))::threadCond,Path,VNs,cpi:edit(Path,threadNotSeen(Thr,Trans)::threadCond,VNs)).
