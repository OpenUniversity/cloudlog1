'/bootstrap':signature(possibleConflict(Expr,Conditions)::'/bootstrap':pred,[Expr::counterExpr,Conditions::'/bootstrap':list(threadCond)]).
'/util':behavior(possibleConflict(Expr,Conditions)::'/bootstrap':pred,!'should succeed if Expr may evaluate to a negative number',possibleConflict(counterIf(counterValue(-3),!thr,3,100),_)).
possibleConflict(Expr,Cond):-possibleTransCombination(Expr,[],Cond),possibleValue(Expr,Cond,V),0>V.
'/util':behavior(possibleConflict(Expr,Conditions)::'/bootstrap':pred,!'should fail if Expr may not evaluate to a negative number',\+possibleConflict(counterPlus(annotation:parentheses(counterIf(counterValue(3),!thr,3,100)),annotation:parentheses(counterIf(counterValue(-3),!thr,6,100))),_)).
'/util':behavior(possibleConflict(Expr,Conditions)::'/bootstrap':pred,!'should unify Conditions with the conditions under which a conflict is possible', (possibleConflict(counterPlus(annotation:parentheses(counterIf(counterValue(3),!thr,3,100)),annotation:parentheses(counterIf(counterValue(-4),!thr,6,100))),Cond),builtin:equals(Cond::'/bootstrap':list(threadCond),[threadSeen(!thr,6),threadSeen(!thr,3)]::'/bootstrap':list(threadCond)))).
'/util':behavior(definiteValue(Expr,Val,Cond)::'/impred':impred,!'should succeed for non-conflicting values, providing their value', ('/impred':simulate(definiteValue(counterValue(3),Val,_),[],'/impred':true),builtin:equals(Val::'/bootstrap':number,3::'/bootstrap':number))).
'/impred':clause(definiteValue(Expr,Val,Cond),'/impred':if(annotation:parentheses('/impred':conj(evalCounter(Expr,Val,Cond),'/impred':pred('/Functional':ge('/Functional':const(Val),'/Functional':const(0),'/bootstrap':number)))),'/impred':true,'/impred':pred(builtin:fail))).
'/util':behavior(definiteValue(Expr,Val,_)::'/impred':impred,!'should provide the real value of a soft counter if not conflicting',builtin:findall(Val,'/bootstrap':number,'/impred':simulate(definiteValue(counterSoft(counterValue(3)),Val,_),[],'/impred':true),[3])).
'/util':behavior(definiteValue(Expr,Val,_)::'/impred':impred,!'should provide positive values only',builtin:findall(Val,'/bootstrap':number,'/impred':simulate(definiteValue(counterPlus(counterSoft(counterValue(-3)),counterValue(2)),Val,_),[],'/impred':true),[2])).
'/bootstrap':deprecated(definiteValue(Expr,Val)::'/impred':impred).
'/bootstrap':signature(definiteValue(Expr,Val,Cond)::'/impred':impred,[Expr::counterExpr,Val::'/bootstrap':number,Cond::'/bootstrap':list(threadCond)]).
'/bootstrap':deprecationReplacement(definiteValue(Expr,Val),'/impred':impred,definiteValue(Expr,Val,Cond)).
'/util':behavior(definiteValue(Expr,Val,Cond)::'/impred':impred,!'should provide the condition under which the value has been acheived', ('/impred':simulate('/impred':with(currentTransaction,!myTrans,'/bootstrap':string,definiteValue(counterIf(counterValue(3),!thr,4,700),Val,Cond)),['/impred':task('/impred':localGet(!'myTrans:thr'),localNum(6),'/impred':localStoreVal)],'/impred':true),builtin:equals(Cond::'/bootstrap':list(threadCond),[threadSeen(!thr,4)]::'/bootstrap':list(threadCond)))).
